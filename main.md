# C++笔记 #
## C++万能头 ##
C++的万能头一般是指  
`#include<bits/stdc++.h>`  
## C++const与指针 ##
`const int * pt1;`  
pt1是指向int常量的指针，指向目标可修改，但指向的目标的值不可修改。  
`int * const pt2;`  
pt2是指向int变量的常量指针，指向目标不可修改，但指向目标的值可修改。  
`const int * const pt3;`  
pt3是指向int常量的常量指针，指向目标不可修改，指向目标的值不可修改。  

const+变量名|const+类型名
-|:-
常量指针，指向目标不可修改|指向常量的指针，或者说指向“const+类型名”类型的指针。  
const的向后传递如水流，将*想象成一个“传送门”是一种不错的做法。
## C++结构体与指针 ##
对于结构体a和结构体指针pt，有如下代码。 

    struct type1  
    {  
    	int num;  
    }a;  
    type1 * pt = &a;

则，我们可以通过pt->num的方式访问a中的num成员。其中“->”被称为“间接成员运算符”。
## 高级数据对象的赋值操作 ##
高级数据对象的赋值操作要求是赋值运算符两侧的数据对象类型一致。  
*未证明的内容*
高级数据对象的赋值操作可能类似于函数重载里的重载解
析。  
至少有一个评判赋值操作是否能进行的准则。  
用户可以在类声明中定义某种转换，参与到这一准则的构建中。  
*未证明的内容*  
## 函数的地址 ##
C++中，函数的地址可以表示为不加参数的函数名。  
有如下代码。  

    void f();
	{
	...
	}
	
	...
	
	int main()
	{
		...
		f;//这里就可以表示一个函数的地址。
		...
	}

## C++中的指针数组与数组指针 ##
指针数组是由指针组成的数组，数组指针是指向一个数组的指针。  
示例代码如下：

    int *pta[10];//定义一个指针数组pta，是由指针组成。
    int *(pta_[10]);//有些人也喜欢这样定义指针数组。
    int (*pat)[10];//定义一个数组指针pat，指向一个数组。

解释如下：  
下标引用运算符（[]）的优先级高于间接访问运算符（*），所以上述代码中在定义pta的时候，其实是定义了一个元素类型为int *的数组，而“*”指出这个数组的元素是int *类型。  
而由于括号的存在，#3中间接访问运算符先执行，故pt应是一个指针。下标引用运算符则指出这是一个指向数组的指针。  
这里有两种理解方案：  

- 先运算什么就是什么  
语句#1先运算“[]”，则#1应定义一个数组，而语句#2先运算“*”，则#2应定义一个指针。  
- 整与散的思想  
`int * pt[10];`  
此句代码中，*符号的作用对象是整个pt[10]，应该将pt[10]视作是指每一个数组元素，是散，是多。  
`int (*pt)[10];`  
此句代码中，，*符号只解除了对pt的引用，是整，是一。  
# C++函数指针初始化 #
C++允许在声明函数指针的时候对函数指针进行初始化。代码如下：  
  
    int (*pt1)(int n) = f;//#1,参数名未省略  
    int (*pt2)(int) = &f;//参数名已省略

语句#2中的&是可选的，具体可见《C和指针》中文版第261页。
经如上声明语句后，(*pt1)和(*pt2)都等价于f。  
因此，如下的语句是合法的。  
`(*pt)(1);`  
这个语句等价于如下语句：  
`f(1);`  
不过应该注意的是，函数指针的声明不能写作如下的形式：  
`int * pt3(int n);`  
pt3将被视为一个函数，返回int *类型的变量。
对于函数指针，应该活用C++11标准提供的auto关键字。  
《C++ Primer Plus,6E》的中文版本对于函数指针数组作了如下的讨论（有删改）：  
`const double *(*pa[3])(const double *,int)={f1,f2,f3};//#3`  
这行代码为我们提供了很好的一个例子——函数指针数组可以在声明时进行初始化——即我们常说的“列表初始化”（C++11）。  
但auto关键字对此支持有限。代码如下：  
`auto pa = {f1,f2,f3};//#4`  
语句#4并不等价于#3，#4是非法的语句。  
这是因为auto关键字的自动类型推断仅仅能用于单值初始化而不能用于列表初始化。但对于#3而言，如下的语句是被允许的：  
`auto pb=pa;//定义一个元素、顺序与元素类型同pa一致的数组pb`  
这也从侧面说明了，auto关键字在自动类型推断后的初始化后的初始化过程中会分配足量的内存空间。好比a和&a[0]的区别。
`sizeof(a)`
返回的是整个数组的内存大小，而
`sizeof(&a[0])`
返回的就是数组a首元素占得内存大小，即使a和&a[0]指向的是同一个地址。  
typedef关键字为函数指针的声明提供了另一种简化，好处在于不必担心写出
`auto tb=*ta;`
这样的语句。示例代码如下：  

    typedef const double *(*ptype)(const double * , int);  
    ptype tb = ta;  

# C++内联函数 #
C++里的内联函数，有点像#define，也就是，编译器使用对应的函数代码替换函数调用，是典型的“牺牲空间换时间”。内联函数的速度稍快于常规函数。  
C++在执行常规函数时，会让程序跳到函数的地址，并在函数执行完毕（好比
`return 0;`
）后返回原来的地址——来回跳跃并且记录跳跃的位置。内联函数则省去了“来回跳跃”这一步奏。  
内联函数应该竟可能地用在执行时间短而处理函数调用机制时间长的代码里。  
要使用内联函数必须满足以下两个条件之一：  

- 在函数声明前加上关键字inline。  
- 在函数定义前加上关键字inline。  
